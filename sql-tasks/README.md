### **Триггеры**
Триггер в MySQL — это определяемая пользователем SQL-команда, которая автоматически вызывается во время операций INSERT, DELETE или UPDATE. Код триггера связан с таблицей и уничтожается после удаления таблицы.
Вы можете определить время действия триггера и указать, когда его нужно активировать – до или после определенного события базы данных.

Виды триггеров:
1. `INSERT` (BEFORE | AFTER)
2. `UPDATE` (BEFORE | AFTER)
3. `DELETE` (BEFORE | AFTER)

Области применения:
1. обеспечение ссылочной целостности при сохранении записи
2. регистрация действий пользователя для аудита таблиц
3. оперативное копирование данных в разных схемах баз данных для обеспечения избыточности и предотвращения единой точки отказа
4. генерации значения производного столбца во время выполнения INSERT

Преимущества:
1. Код выполняется на уровне БД 
2. Иногда они помогают сохранить короткие и простые коды SQL
3. Они помогают поддерживать ограничения целостности в таблицах базы данных, особенно когда не определены ограничения первичного ключа и внешнего ключа.

Недостатки:
1. Трудно поддерживать, т.к. код хранится в БД.
2. Трудно отлаживать 
3. Использование триггеров может замедлить производительность приложения
4. Стоимость создания триггеров может быть больше для таблиц, в которых высока частота операций DML (вставка, удаление и обновление), таких как массовая вставка.
5. Триггер может быть привязан только к одной таблице. 

Примеры кода триггеров:
 1. [modify_triggers](/sql-tasks/triggers/modify_triggers.sql).

 2. [logs_triggers](/sql-tasks/triggers/logs_triggers.sql).


### **Ключи**
Ключи - это поля в реляционной таблице, которые создают отношения между другими таблицами, поддерживают целостность, уникальность и т. Д. 

Первичный ключ - это колонка (column) или колонки, не имеющие в строках дублирующих значений.
Может быть несколько потенциальных первичных ключей. 

Внешний ключ - колонка в которой содержится первичный ключ другой таблицы.

Связи через внешние ключи показано в файле keys/foreign_keys.sql

Помимо проверки корректности значения внешнего ключа при добавлении и изменении строк дочерней таблицы, 
необходимо также предотвратить нару-
шение ссылочной целостности при удалении и изменении строк родительской таблицы. Для
этого существует несколько способов.
1. Запрет (RESTRICT): если на строку родительской таблицы ссылается хотя бы одна
строка дочерней таблицы, то удаление родительской строки и изменение значения первич-
ного ключа в такой строке запрещаются. 
 
2. Каскадное удаление/обновление (CASCADE): при удалении строки из родительской
таблицы автоматически удаляются все ссылающиеся на нее строки дочерней таблицы; при
изменении значения первичного ключа в строке родительской таблицы автоматически обно-
вляется значение внешнего ключа в ссылающихся на нее строках дочерней таблицы.

3. Обнуление (SET NULL): при удалении строки и при изменении значения первичного
ключа в строке значение внешнего ключа во всех строках, ссылающихся на данную, автома-
тически становится неопределенным (NULL).


### **Представления**
Представление (VIEW) — объект базы данных, являющийся результатом выполнения запроса к базе данных, определенного с помощью оператора SELECT, в момент обращения к представлению.
Представление доступно для пользователя как таблица, но само оно не содержит данных, а извлекает их из таблиц в момент обращения к нему.

 - Кеширование результатов выборки не работает
 - query cache работает на уровне пользователя
 - Могу тбыть основаны как на таблицах так и на других представлениях (32 уровня вложенности)

Преимущества
1. Гибкая настройка прав доступа
2. Разделение логики хранения и по.
3. Удобство в использовании за счет автоматического выполнения таких действий как доступ к определенной части строк и/или столбцов, получение данных из нескольких таблиц и их преобразование с помощью различных функций.

Ограничения:
1. нельзя повесить триггер на представление,
2. нельзя сделать представление на основе временных таблиц; нельзя сделать временное представление;
3. в определении представления нельзя использовать подзапрос в части FROM,
4. в определении представления нельзя использовать системные и пользовательские переменные; внутри хранимых процедур нельзя в определении представления использовать локальные переменные или параметры процедуры,
5. в определении представления нельзя использовать параметры подготовленных выражений (PREPARE),
6. таблицы и представления, присутствующие в определении представления должны существовать.
7. только представления, удовлетворяющие ряду требований, допускают запросы типа UPDATE, DELETE и INSERT.

Примеры в views/example.sql

Представление называется обновляемым, если к нему могут быть применимы операторы UPDATE и DELETE для изменения данных в таблицах, на которых основано представление. Для того, чтобы представление было обновляемым должно быть выполнено 2 условия:
Соответствие 1 к 1 между строками представления и таблиц, на которых основано представление, т.е. каждой строке представления должно соответствовать по одной строке в таблицах-источниках.
Поля представления должны быть простым перечислением полей таблиц, а не выражениеями col1/col2 или col1+2.

### **Транзакции**

Транзакция представляет собой группу запросов SQL, обрабатываемых атомарно, то есть как единое целое.

Нужно понимать и знать следующее:

1) ACID - критерии для транзакций (Атомарность, Согласованость, Изолированость, Долговечность)

Атомарность. Транзакция должна функционировать как единая неделимая ра­бочая единица таким образом, чтобы вся она была либо выполнена, либо отменена. Для атомарных транзакций не существует такого понятия, как частичное выполнение: все или ничего.

Согласованность. База данных всегда должна переходить из одного согласован­ного состояния в другое. Если транзакция не будет подтверждена, ни одно из изменений не отразится в базе данных.

Изолированность. Результаты транзакции обычно невидимы другим транзак­циям, пока она не подтверждена. 

Долговечность. После подтверждения внесенные в ходе транзакции изменения становятся постоянными. Это значит, что они должны быть записаны так, чтобы данные не потерялись при сбое системы. 


2) Уровни изоляции

READ UNCOMMITTED (чтение незафиксированных данных). На этом уровне изолированности транзакции могут видеть результаты незавершенных транзакций. Вы можете столкнуться с множеством проблем, если не знаете абсолютно точно, что делаете. Используйте этот уровень, только если у вас есть на то веские причины. На практике этот уровень применя­ется редко, поскольку в этом случае производительность лишь немного выше, чем на других уровнях, имеющих множество преимуществ. Чтение незавершенных данных называют еще черновым, или «грязным» чтением (dirty read).

READ COMMITTED (чтение фиксированных данных). Это уровень изолированности, который устанавливается по умолча­нию в большинстве СУБД (но не в MySQL!). Он соответствует приведенному ранее простому определению изолированности: транзакция увидит только те изменения, которые к моменту ее начала подтверждены другими транзакциями, а произведен­ные ею изменения останутся невидимыми для других транзакций, пока текущая не будет подтверждена. На этом уровне возможно так называемое неповторяющееся чтение (nonrepeatable read). Это означает, что вы можете выполнить одну и ту же команду дважды и получить разный результат.

REPEATABLE READ (повторяющееся чтение). Этот уровень изолированности позволяет решить проблемы, ко­торые возникают на уровне READ UNCOMMITTED. Он гарантирует, что любые строки, которые считываются транзакцией, будут выглядеть одинаково при последовательных операциях чтения в пределах одной транзакции, однако теоретически на этом уровне возможна другая проблема, которая называется фантомным чтением (phantom reads). Проще говоря, фантомное чтение может произойти в случае, если вы выбираете некоторый диапазон строк, затем другая транзакция вставляет в него новую строку, после чего вы снова выбираете тот же диапазон. В результате вы увидите новую, фантомную строку. InnoDB и XtraDB решают проблему фантомного чтения с помощью многоверсионного управления конку­рентным доступом (multiversion concurrency control). Уровень изолированности REPEATABLE READ устанавливается в MySQL по умол­чанию.

SERIALIZABLE(упорядочиваемость). Самый высокий уровень изолированности, который решает про­блему фантомного чтения, заставляя транзакции выполняться в таком порядке, чтобы исключить возможность конфликта. Если коротко, уровень SERIALIZABLE блокирует каждую читаемую строку. На этом уровне может возникать множество задержек и конфликтов блокировок. Нам редко встречались люди, использующие этот уровень, но потребности вашего приложения могут заставить применять его, смирившись с меньшей степенью конкурентного доступа, но обеспечивая стабильность данных.


Для понимания транзакций лучше ознакомится со статье https://oracle-patches.com/db/mysql/tranzaktsii-v-baze-dannyh-mysql


